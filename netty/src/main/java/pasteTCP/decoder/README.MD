## 编解码技术

基于java提供的对象输入输出流ObjectInput/OutputStream可以直接把java对象作为可存储的字节数组写入文件，也可传入到网络上。
基于JDK默认的序列化机制可以避免操作底层的字节数组，提升开发效率。

当进行远程跨进程服务调用时，需要把传输的java对象编码为字节数组or ByteBuffer对象。而当远程服务读取到ByteBuffer对象或者字节对象时，
需要将其解码为发送时的java对象。这被称为java对象编解码技术。

java序列化仅仅是java编解码技术的一种，由于它的缺陷，出现了多种编码技术和框架。

## java序列化

jdk1.1就提供了，只需要实现java.io.Serializable并生成序列ID。
但是在RPC（远程服务调用）时，很少使用java序列化进行消息的编解码和传输。

#### reason

##### 无法跨语言

java序列化技术是java语言内部的私有协议，其他语言不支持。对于java序列化后的字节数组，别的语言无法进行反序列化。

##### 序列化的码流太大

##### 序列化性能太低
 
## 主流编解码框架 

#### Google的Protobuf

最大的特点是基于二进制，因此比传统的 XML表示高效短小得多。虽然是二进制数据格式，但并没有因此变得复杂，可以很方便的对其基于二进制的协议进行扩展，并且很方便的能让新版本的协议兼容老的版本。

#### FaceBook的Thrift

Thrift通过一个中间语言(IDL, 接口定义语言)来定义RPC的接口和数据类型，然后通过一个编译器生成不同语言的代码

Thrift实际上是实现了C/S模式，通过代码生成工具将接口定义文件生成服务器端和客户端代码（可以为不同语言），从而实现服务端和客户端跨语言的支持。
用户在Thirft描述文件中声明自己的服务，这些服务经过编译后会生成相应语言的代码文件，然后用户实现服务（客户端调用服务，服务器端提服务）便可以了。
其中protocol（协议层, 定义数据传输格式，可以为二进制或者XML等）和transport（传输层，定义数据传输方式，可以为TCP/IP传输，内存共享或者文件共享等）被用作运行时库。


#### Jboss Marshalling

JBoss Marshalling 是一个 Java 对象序列化包，对 JDK 默认的序列化框架进行了优化，但又保持与 Serializable 接口的兼容，同时增加了一些可调用的参数和附加的属性，这些参数可通过工厂类进行配置。


## java序列化

实现java.io.Serializable接口，根据情况生成id，这个类就能够通过java.io.ObjectInout和java.io.ObjectOutput序列化和反序列化。

如果不考虑跨语言调用，对序列化没有性能要求，java默认序列化机制是最明智的选择之一。


